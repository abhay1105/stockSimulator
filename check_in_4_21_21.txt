SERVER SIDE


Account Class

package com.abhay.stockSimGame;

import java.util.ArrayList;

// class will manage all of a player's positions
public class Account {

    // all variables located here
    private ArrayList<Position> positions;
    private double initialBalance, investedAmount, profitOrLoss, currentValue, currentBalance;

    // class constructor
    public Account(double initialBalance) {
        this.initialBalance = initialBalance;
        positions = new ArrayList<>();
        investedAmount = 0;
        profitOrLoss = 0;
        currentValue = 0;
        currentBalance = initialBalance;
    }

    // all getter methods located here
    public ArrayList<Position> getPositions() { return positions; }
    public double getInitialBalance() { return initialBalance; }

    public double getInvestedAmount() {
        double total = 0;
        for (Position position: positions) {
            total += position.getMoneyInvested();
        }
        investedAmount = total;
        return total;
    }

    public double getProfitOrLoss(double sharePrice) {
        double total = 0;
        for (Position position: positions) {
            total += position.getProfit(sharePrice);
        }
        profitOrLoss = total;
        return total;
    }

    public double getCurrentValue(double sharePrice) {
        double total = 0;
        for (Position position: positions) {
            total += position.getCurrentValue(sharePrice);
        }
        currentValue = total;
        return total;
    }

    public double getCurrentBalance() { return currentBalance; }

    // both methods below will only be used when buying or selling shares in a position

    // method to subtract money from our account's current balance
    public void subtractMoney(double money) {
        currentBalance -= money;
    }

    // method to add money to our account's current balance
    public void addMoney(double money) {
        currentBalance += money;
    }

}


BarData Class

package com.abhay.stockSimGame;

// class will help in storing our individual data points
public class BarData {

    // all variables located here
    // these variables will simply assist in making sure we have all of the data from the API call stored, regardless
    // of if we choose to use it
    private Stock stock;
    private String date;
    private double open, high, low, close, adjustedClose, volume, dividendAmount, splitCoefficient;

    // class constructor
    public BarData(Stock stock, String date, double open, double high, double low, double close, double adjustedClose, double volume,
                   double dividendAmount, double splitCoefficient) {
        this.stock = stock;
        this.date = date;
        this.open = open;
        this.high = high;
        this.low = low;
        this.close = close;
        this.adjustedClose = adjustedClose;
        this.volume = volume;
        this.dividendAmount = dividendAmount;
        this.splitCoefficient = splitCoefficient;
    }

    // by changing the toString() method it will be easier for us to view any information quicker
    @Override
    public String toString() {
        return stock.getSymbol() + "   D:" + date + "   O:" + open + "   H:" + high + "   L:" + low + "   C:" +
                close + "   AC:" + adjustedClose + "   V:" + volume + "   DA:" + dividendAmount + "   SC:" + splitCoefficient;
    }


    // all getter methods located here
    public Stock getStock() { return stock; }
    public String getDate() { return date; }
    public double getOpen() { return open; }
    public double getHigh() { return high; }
    public double getLow() { return low; }
    public double getClose() { return close; }
    public double getAdjustedClose() { return adjustedClose; }
    public double getVolume() { return volume; }
    public double getDividendAmount() { return dividendAmount; }
    public double getSplitCoefficient() { return splitCoefficient; }


}


ClientConnection Class

package com.abhay.stockSimGame;


import io.vertx.core.http.ServerWebSocket;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.rxjava.core.Vertx;
import org.slf4j.Logger;

import java.io.IOException;
import java.util.concurrent.atomic.AtomicBoolean;

// class will take care of the connection between the server and a client
public class ClientConnection {

    // all variables located here
    private ServerWebSocket              webSocket;
    private Logger                       logger;
    private Player                       player;
    private Game                         game;
    private Vertx                        m_vertx;

    // class constructor
    public ClientConnection(Vertx m_vertx, ServerWebSocket webSocket, Logger logger) {
        this.m_vertx = m_vertx;
        this.webSocket = webSocket;
        this.logger = logger;
        webSocket.handler(buffer -> {
            logger.info(buffer.toString());
            try {
                handleMessage(buffer.toString());
            } catch (IOException | InterruptedException e) {
                e.printStackTrace();
            }
        });
    }

    // method to remove a client connection from a running game
    public void removePlayerFromGame() {

    }

    // method takes in every message that is incoming from the Client and processes it
    public void handleMessage(String message) throws IOException, InterruptedException {
        JsonObject json = new JsonObject(message);
        String messageType = json.getString("type");
        switch (messageType) {
            case "new_player":
                createNewPlayer(json.getString("player_name"));
                break;
            case "new_or_current_game":
                createOrJoinGame(json);
                break;
            case "stock_data_request_full":
                sendStockDataFull(json);
                break;
            case "stock_data_request_interval":
                sendStockDataInterval(json);
                break;
            case "buy_request":
                buyShares(json);
                break;
            case "sell_request":
                sellShares(json);
                break;
        }
    }

    // method creates a new player that is associated with this ClientConnection object
    public void createNewPlayer(String playerName) {
        player = new Player(playerName);
        System.out.println("NEW PLAYER CREATED WITH NAME:      " + playerName);
    }

    // method to send the information in order to update a client's account page
    public void sendUpdatedAccountPage(Game game) {
        JsonObject json = new JsonObject();
        json.put("player_name", player.getName());
        JsonArray jsonArray = new JsonArray();
        for (Stock stock: game.getMarket().getStocks()) {
            jsonArray.add(stock.getSymbol());
        }
        json.put("stocks", jsonArray);
        json.put("type", "updated_account_page_info");
        webSocket.writeTextMessage(json.encode());
    }

    // method will be in charge of creating a new game or joining a current one
    public void createOrJoinGame(JsonObject json) throws IOException, InterruptedException {
        // purpose is due to the fact that an updated accountPage should be sent regardless of if they create a
        // game or if they join a game
        game = new Game("multiple-stocks");
        if (json.getString("player_choice").equals("yes")) {
            game.addPlayer(player);
        } else {
            System.out.println("need to join a game. game codes coming soon");
        }
        sendUpdatedAccountPage(game);
    }

    // method will send all of the appropriate stock data the server has based on the request made by the client
    public void sendStockDataFull(JsonObject json) {
        String stockSymbol = json.getString("stock_symbol");
        JsonObject jsonObject = new JsonObject();
        JsonArray jsonArray = new JsonArray();
        String stockName = null;
        if (game.getStockBySymbol(stockSymbol) != null) {
            for (BarData barData: game.getStockBySymbol(stockSymbol).getHistoricalData()) {
                jsonArray.add(barData.getOpen() / barData.getSplitCoefficient());
                if ((barData.getOpen() / barData.getSplitCoefficient()) > 2000) {
                    System.out.println(barData.toString());
                }
            }
            stockName = game.getStockBySymbol(stockSymbol).getName();
        }
        jsonObject.put("open_prices", jsonArray);
        if (stockName != null) {
            jsonObject.put("stock_name", stockName);
        }
        jsonObject.put("stock_symbol", stockSymbol);
        jsonObject.put("type", "stock_chart_data_full");
        webSocket.writeTextMessage(jsonObject.encode());
    }

    // used in sendStockDataInterval() method
    private int dataCountMaster = 0;

    // method will send all of the appropriate stock data in intervals based on a specific time length
    public void sendStockDataInterval(JsonObject json) throws InterruptedException {

        JsonArray jsonArray = json.getJsonArray("stock_symbols");
        double intervalTime = json.getDouble("interval_time");
        double amountOfDataPerInterval = json.getDouble("amount_per_interval");
        AtomicBoolean stopTimer = new AtomicBoolean(false);

        long timerID = m_vertx.setPeriodic((long) intervalTime, aLong -> {
            // this chunk of code is expected to go into the actual timer body
            JsonArray completeIntervalData = new JsonArray();
            for (Object stockSymbol: jsonArray) {
                int dataCountIndividual = dataCountMaster;
                JsonObject oneStockInterval = new JsonObject();
                JsonArray oneStockIntervalPrices = new JsonArray();
                String stockName = null;
                if (game.getStockBySymbol((String) stockSymbol) != null) {
                    // or statement in for loop will either give us the next blank data points based on the client's request or
                    // if there is not enough, it will simply give the remaining items in the data ArrayList
                    double endOfInterval = dataCountIndividual + amountOfDataPerInterval;
                    for (int i = dataCountIndividual;i < endOfInterval && i < game.getStockBySymbol((String) stockSymbol).getHistoricalData().size();i++) {
                        System.out.println(i);
                        BarData barData = game.getStockBySymbol((String) stockSymbol).getHistoricalData().get(i);
                        oneStockIntervalPrices.add(barData.getOpen() / barData.getSplitCoefficient());
                        dataCountIndividual = i + 1;
                    }
                    // this message will allow the client to know whether or not there is more data to come
                    if (dataCountIndividual == game.getStockBySymbol((String) stockSymbol).getHistoricalData().size()) {
                        oneStockInterval.put("data_finished", "true");
                        stopTimer.set(true);
                    } else {
                        oneStockInterval.put("data_finished", "false");
                    }
                    stockName = game.getStockBySymbol((String) stockSymbol).getName();
                }
                oneStockInterval.put("open_prices", oneStockIntervalPrices);
                if (stockName != null) {
                    oneStockInterval.put("stock_name", stockName);
                }
                System.out.println(stockSymbol);
                oneStockInterval.put("stock_symbol", (String) stockSymbol);
                completeIntervalData.add(oneStockInterval);
            }
            dataCountMaster += amountOfDataPerInterval;
            JsonObject finalMessage = new JsonObject();
            finalMessage.put("complete_interval_data", completeIntervalData);
            finalMessage.put("type", "stock_chart_data_interval");
            webSocket.writeTextMessage(finalMessage.encode());
        });

        // stopping the timer once there is no longer enough data in one of the stocks (at least for now, eventually
        // we will add an end time to stop)
        if (stopTimer.get()) {
            System.out.println("stopped timer due to lack of data");
            m_vertx.cancelTimer(timerID);
        }

    }

    // method to buy shares in a stock
    public void buyShares(JsonObject json) {
        String stockSymbol = json.getString("stock_symbol");
        double sharePrice = json.getDouble("share_price");
        int numOfShares = json.getInteger("number_of_shares");
        for (Position position: player.getAccount().getPositions()) {
            if (position.getStock().getSymbol().equals(stockSymbol)) {
                position.buyShares(numOfShares, sharePrice);
                break;
            }
        }
    }

    // method to sell shares in a stock
    public void sellShares(JsonObject json) {
        String stockSymbol = json.getString("stock_symbol");
        double sharePrice = json.getDouble("share_price");
        int numOfShares = json.getInteger("number_of_shares");
        for (Position position: player.getAccount().getPositions()) {
            if (position.getStock().getSymbol().equals(stockSymbol)) {
                position.sellShares(numOfShares, sharePrice);
                break;
            }
        }
    }

}


Driver Class

package com.abhay.stockSimGame;

import java.io.IOException;
import java.util.Set;
import io.vertx.core.VertxOptions;
import io.vertx.rxjava.core.Vertx;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Driver {

    private Vertx   m_vertx = null;
    private Logger  m_logger;
    public static void main(String args[]) throws IOException, InterruptedException {
        Driver d = new Driver();
        Runtime.getRuntime().addShutdownHook(new Thread() {
            public void run() {
                System.out.println("Running Shutdown Hook");
                d.stop();
            }
        });
        d.start();
    }

    public Driver() {
        m_logger = LoggerFactory.getLogger("DRIVER");
    }

    public void start() {
        m_logger.info("Starting Driver");
        m_vertx = Vertx.vertx(new VertxOptions().setBlockedThreadCheckInterval(1000));
        m_vertx.deployVerticle(new ServerVerticle(m_vertx), (result) -> {
            if (result.succeeded()) {

            } else {

            }
        });

    }

    public void stop() {
        m_logger.info("Stopping Driver");
        Set<String> ids = m_vertx.deploymentIDs();
        for (String id : ids) {
            m_vertx.undeploy(id, (result) -> {
                if (result.succeeded()) {

                } else {

                }
            });
        }
    }

}


Game Class

package com.abhay.stockSimGame;

import java.io.IOException;
import java.util.ArrayList;

// class will take care of the entire management of game
public class Game {

    // some good tips to note will be located here

    // the starting screen will have some sort of feature to either join a game or create a game (so generating number
    //    and letter game codes will be important later) these codes can be verified in some sort of arrayList or something
    // I can use an animation timer in order to simulate the smaller time frame (this will also make it easier for me to
    //    redraw the same time length of graphs when the user switches a stock from a list view)
    // I can maybe add a checkbox or a dropdown in order to select a game mode
    // *******We can have a separate screen on our starting page so that a user can set their desired options for a new game,
    //    however none of the options will need to be registered until they actually press new game

    // Alpha-Vantage API ID
    // 9MFKMGNE0JRT1HWU


    // all variables located here
    private String mode;
    private int numOfPlayers, maxNumOfPlayers;
    private double timePeriod, timeProgress;
    private Market market;
    private ArrayList<Player> players = new ArrayList<>();
    private String gameID;

    // class constructor
    public Game(String mode) throws IOException, InterruptedException {
        this.mode = mode;
        // game ID can be randomly created in here
        determineMarket(); // will use the settings given in order to create the market the host wants
        retrieveMarketHistoricalData(); // will get any data that we don't already have
    }

    // all getter methods located here
    public String getMode() { return mode; }
    public int getNumOfPlayers() { return numOfPlayers; }
    public int getMaxNumOfPlayers() { return maxNumOfPlayers; }
    public double getTimePeriod() { return timePeriod; }
    public double getTimeProgress() { return timeProgress; }
    public Market getMarket() { return market; }
    public ArrayList<Player> getPlayers() { return players; }
    public String getGameID() { return gameID; }

    // method to add a player
    public void addPlayer(Player player) {
        players.add(player);
        createPlayerPositions(player);
    }

    // method to determine the stocks the players will trade with (dependent on which mode the player will choose)
    public void determineMarket() {
        ArrayList<Stock> stocks = new ArrayList<>();
        stocks.add(new Stock("Tesla Motors", "TSLA"));
        if (mode.equals("one-stock")) {
            market = new Market(stocks);
        } else if (mode.equals("multiple-stocks")) {
            stocks.add(new Stock("Gamestop", "GME"));
            stocks.add(new Stock("International Business Machines", "IBM"));
            market = new Market(stocks);
        }
    }

    // method to retrieve the historical information required in order to play the games with the selected stocks
    public void retrieveMarketHistoricalData() throws IOException, InterruptedException {
        for (Stock stock: market.getStocks()) {
            stock.retrieveStockHistoricalData();
            stock.printHistoricalDataSize();
        }
    }

    // method to create all of the position objects for our players
    public void createPlayerPositions(Player player) {
        for (Stock stock: market.getStocks()) {
            player.getAccount().getPositions().add(new Position(player.getAccount(), stock));
        }
    }

    // method to return a stock based off of its symbol
    public Stock getStockBySymbol(String symbol) {
        for (Stock stock: market.getStocks()) {
            if (stock.getSymbol().equals(symbol)) {
                return stock;
            }
        }
        return null;
    }

}


Market Class

package com.abhay.stockSimGame;

import java.util.ArrayList;

// class will manage all of the stocks that the players are allowed to invest in
public class Market {

    // all variables located here
    private ArrayList<Stock> stocks;

    // class constructor
    public Market(ArrayList<Stock> stocks) {
        this.stocks = stocks;
    }

    // all getter methods located here
    public ArrayList<Stock> getStocks() { return stocks; }


}


Player Class

package com.abhay.stockSimGame;


// class will manage a player in the game
public class Player {

    // all variables located here
    private String name;
    private Account account;

    // class constructor
    public Player(String name, double initialBalance) {
        this.name = name;
        this.account = new Account(initialBalance);
    }

    // all getter methods located here
    public String getName() { return name; }
    public Account getAccount() { return account; }

}


Position Class

package com.abhay.stockSimGame;


// class will represent one position in a stock
public class Position {

    // all variables located here
    private Stock stock;
    private int numOfShares;
    private double moneyInvested;
    private Account account;

    // class constructor
    public Position(Account account, Stock stock) {
        this.account = account;
        this.stock = stock;
        numOfShares = 0;
        moneyInvested = 0;
    }

    // all getter methods located here
    public Account getAccount() { return account; }
    public Stock getStock() { return stock; }
    public int getNumOfShares() { return numOfShares; }
    public double getMoneyInvested() { return moneyInvested; }
    public double getCurrentValue(double sharePrice) { return sharePrice * numOfShares; }
    public double getProfit(double sharePrice) { return getCurrentValue(sharePrice) - getMoneyInvested(); }

    // method to buy shares (aka increase position in stock)
    public void buyShares(int numOfShares, double sharePrice) {
        this.numOfShares += numOfShares;
        moneyInvested += sharePrice * numOfShares;
        account.subtractMoney(sharePrice * numOfShares);
    }

    // method to sell shares (aka decrease position in stock)
    public void sellShares(int numOfShares, double sharePrice) {
        this.numOfShares -= numOfShares;
        account.addMoney(sharePrice * numOfShares);
    }

}


ServerVerticle Class

package com.abhay.stockSimGame;

import io.vertx.core.http.HttpServer;
import io.vertx.core.json.JsonObject;
import io.vertx.config.ConfigRetriever;
import io.vertx.core.AbstractVerticle;
import io.vertx.ext.web.Router;
import io.vertx.rxjava.core.Vertx;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.HashMap;

public class ServerVerticle extends AbstractVerticle {

    // all variables located here
    private final Logger                                m_logger;
    private Router                                      m_router;
    private JsonObject                                  m_config = null;
    private HashMap<String, ClientConnection>           map = new HashMap<>();
    private Vertx                                       m_vertx;

    public ServerVerticle(Vertx m_vertx) {
        super();
        m_logger = LoggerFactory.getLogger("APIVERTICLE");
        this.m_vertx = m_vertx;
    }

    @Override
    public void start() throws Exception {
        m_logger.info("Starting StarterVerticle");

        ConfigRetriever retriever = ConfigRetriever.create(vertx);
        retriever.getConfig(
                config -> {

                    m_logger.info("config retrieved");

                    if (config.failed()) {

                        m_logger.info("No config");

                    } else {

                        m_logger.info("Got config");
                        m_config = config.result();

                        // the actual creation of the server
                        HttpServer server = vertx.createHttpServer();
                        // whenever a new client has connected
                        server.websocketStream().handler(socket -> {
                            // creates a new ClientConnection for every new client that connects to the server
                            ClientConnection newClient = new ClientConnection(m_vertx, socket, m_logger);
                            // map will allow us to keep track of all of our ClientConnections using the respective
                            // socket IDs
                            map.put(socket.textHandlerID(), newClient);
                            m_logger.info("Connection ID=" + socket.textHandlerID());
                            // endHandler will run whenever a client has disconnected from the server
                            socket.endHandler((Void) -> {
                                // will need to remove the ClientConnection from the map (will also need to remove the
                                // players associated with this connection from the game)
                                map.remove(socket.textHandlerID());
                                m_logger.info("socket closed");
                            });
                        });
                        // kind of like a traffic controller in that any new clients will be directed to a different
                        // port after they have reached port 8080
                        server.listen(8080, res -> {
                            if (res.succeeded()) {
                                // this line is almost like an advertisement in a way, because it tells everyone
                                // that is now listening
                                m_logger.info("Server now listening on 8080");
                            } else {
                                m_logger.error("Server failed to start");
                            }
                        });
                    }
                }
        );
    }

    @Override
    public void stop() throws Exception {
        m_logger.info("Stopping StarterVerticle");
    }

}


Stock Class

package com.abhay.stockSimGame;


import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import java.io.*;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.text.DateFormatSymbols;
import java.util.*;

// class will manage a specific symbol in market
public class Stock {

    // all variables located here
    private String name, symbol;
    private double pricePerShare;
    private ArrayList<BarData> historicalData;

    // class constructor
    public Stock(String name, String symbol) {
        this.name = name;
        this.symbol = symbol;
        this.historicalData = new ArrayList<>();
    }

    // all getter methods located here
    public String getName() { return name; }
    public String getSymbol() { return symbol; }
    public double getPricePerShare() { return pricePerShare; }
    public ArrayList<BarData> getHistoricalData() { return historicalData; }

    // method to neatly print our historical data
    public void printHistoricalDataSize() {
        System.out.println("Symbol: " + symbol + "      " + historicalData.size() + " data points");
    }

    // method to retrieve historical data about this specific stock over a period of time
    public void retrieveStockHistoricalData() throws IOException, InterruptedException {
        // if the stock data for a specific stock does not already exist in our files, we will make an API call for it
        // in order to retrieve that data and have it long-term

        // here, we would need to figure out if a specific file already exists
        JSONParser jsonParser = new JSONParser();
        try (FileReader reader = new FileReader("C:\\Users\\Kalyani Koyya\\Desktop\\Abhay's Desktop\\stockSimGame2.0\\stockData\\TIME_SERIES_DAILY_ADJUSTED_FULL\\" + symbol + ".json")) {

            System.out.println(historicalData.size());

            // we don't want to accidentally add the same data twice
            if (historicalData.size() == 0) {

                JSONObject json = (JSONObject) jsonParser.parse(reader);
                JSONObject timeSeriesData = (JSONObject) json.get("Time Series (Daily)");
                Set<String> keys = timeSeriesData.keySet();

                Map<Date, BarData> dataValues = new HashMap<>();
                DateFormatSymbols dfs = new DateFormatSymbols();

                for (String key: keys) {

                    JSONObject datum = (JSONObject) timeSeriesData.get(key);
                    BarData barData = new BarData(
                            this, key,
                            Double.parseDouble((String) datum.get("1. open")),
                            Double.parseDouble((String) datum.get("2. high")),
                            Double.parseDouble((String) datum.get("3. low")),
                            Double.parseDouble((String) datum.get("4. close")),
                            Double.parseDouble((String) datum.get("5. adjusted close")),
                            Double.parseDouble((String) datum.get("6. volume")),
                            Double.parseDouble((String) datum.get("7. dividend amount")),
                            Double.parseDouble((String) datum.get("8. split coefficient")));

                    int year = Integer.parseInt(key.substring(0, 4));
                    int month = Integer.parseInt(key.substring(5, 7));
                    int day = Integer.parseInt(key.substring(9));

                    String[] months = dfs.getMonths();
                    String monthName = months[month - 1].toUpperCase();

                    Date date = new Date(year, month, day);
                    dataValues.put(date, barData);

                }

                Map<Date, BarData> orderedDataValues = new TreeMap<>(dataValues);
                for (Date date: orderedDataValues.keySet()) {
                    historicalData.add(orderedDataValues.get(date));
                }

            }

        } catch (ParseException e) {
            e.printStackTrace();
            System.out.println("error in parsing file");
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            System.out.println("error in finding file");
            writeStockFile();
        }

    }

    // method will write a file containing the information gathered from the API about a particular stock
    public void writeStockFile() throws IOException, InterruptedException {

        // if not, we make the request
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create("https://www.alphavantage.co/query?function=TIME_SERIES_DAILY_ADJUSTED&symbol=" + symbol + "&outputsize=full&apikey=9MFKMGNE0JRT1HWU"))
                .header("x-rapidapi-key", "SIGN-UP-FOR-KEY")
                .header("x-rapidapi-host", "alpha-vantage.p.rapidapi.com")
                .method("GET", HttpRequest.BodyPublishers.noBody())
                .build();
        HttpResponse<String> response = HttpClient.newHttpClient().send(request, HttpResponse.BodyHandlers.ofString());

        // now that the request has been made, let's save it as a file so that we won't need to use a request
        // on it in the future

        // creates a new file in our desired directory
        File newStockFile = new File("C:\\Users\\Kalyani Koyya\\Desktop\\Abhay's Desktop\\stockSimGame2.0\\stockData\\TIME_SERIES_DAILY_ADJUSTED_FULL\\" + symbol + ".json");
        if (newStockFile.createNewFile()) {
            System.out.println(symbol + "    TIME_SERIES_DAILY_ADJUSTED_FULL    FILE CREATED");
        }

        // creates a fileWriter that will write the API result to the file we created above
        FileWriter fileWriter = new FileWriter(newStockFile);
        fileWriter.write(response.body());
        fileWriter.flush();
        fileWriter.close();

        // we will need to call the retrieveStockHistoricalData() function again in order to create the BarData
        // objects for the stock
        retrieveStockHistoricalData();

    }

}






CLIENT SIDE


StartingPage Class

package sample;

import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.core.eventbus.MessageProducer;
import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;

public class StartingPage extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {

        // loads the first page we want to load in our application
        Parent root = FXMLLoader.load(getClass().getResource("StartingPage.fxml"));
        primaryStage.setTitle("Stock Simulator 2.0");
        primaryStage.setScene(new Scene(root, 1500, 750));
        primaryStage.show();

    }

    public static void main(String[] args) {
        launch(args);
    }

}


StartingPageController Class

package sample;

import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.core.eventbus.MessageProducer;
import io.vertx.core.json.Json;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import javafx.application.Platform;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.TextField;
import javafx.stage.Stage;
import org.slf4j.Logger;

import javafx.event.ActionEvent;
import org.slf4j.LoggerFactory;

import java.io.IOException;

public class StartingPageController {

    // all fx elements located here
    @FXML
    TextField txtfiEnterNickname, txtfiGameMode;
    @FXML
    Button btnConnect;

    private final ClientHandler clientHandler;
    private final Logger logger;

    // to communicate with vertx websocket using verticle
    private final EventBus vertxEventBus;
    // to receive messages from server
    private final MessageConsumer<String> busConsumer;
    // to send messages to server
    private final MessageProducer<String> busProducer;

    private AccountPageController accountPageController;
    private ActionEvent actionEvent;
    private Parent root;

    // controller constructor
    public StartingPageController() throws IOException {

        // since this is the first controller our application will go to, we will need to create new objects in order
        // to handle the incoming server messages, as well to send messages to our server
        clientHandler = new ClientHandler("127.0.0.1", 8080, "nickname");
        logger = LoggerFactory.getLogger(StartingPageController.class);
        vertxEventBus = clientHandler.getVertxEventBus();
        // doing .consumer() and .publisher() creates new busProducers and busConsumers with the string addresses
        busConsumer = vertxEventBus.consumer("socket-inbound");
        busProducer = vertxEventBus.publisher("socket-outbound");

        // lines below will allow us to make sure that any other fxControllers have the access to the objects
        // required to communicate with the server
        FXMLLoader loader = new FXMLLoader(getClass().getResource("AccountPage.fxml"));
        root = loader.load();
        accountPageController = loader.getController();
        accountPageController.transferVertxObjects(clientHandler);

        // attach a handler to receive messages
        busConsumer.handler(msg -> {
            String message = msg.body();
            logger.info("Received {}", message);

            // handles all incoming messages from GameClientVerticle
            try {
                handleMessage(message);
            } catch (IOException e) {
                e.printStackTrace();
            }

            // for now echo it back
            // busProducer.write("ECHO " + message);
        });
    }

    // method to connect the client to the server
    public void connectToServer(ActionEvent event) {

        // connecting the javafx client to our http server
        clientHandler.startClient("127.0.0.1", 8080, "nickname");
        // used to load next scene
        actionEvent = event;

    }

    // method takes in every message that is incoming from the busProducer in the GameClientVerticle and processes it
    public void handleMessage(String message) throws IOException {
        JsonObject json = new JsonObject(message);
        if (json.getString("type").equals("socket_connected")) {
            // the first thing we are doing when the socket is officially connected
            sendNewPlayerName();
            sendCurrentOrNewGame();
        } else if (json.getString("type").equals("updated_account_page_info")) {
            receiveUpdatedAccountPage(json);
        }
    }

    // method to send a message of the new player's name to the server
    public void sendNewPlayerName() {
        String name = txtfiEnterNickname.getText();
        JsonObject json = new JsonObject();
        json.put("player_name", name);
        json.put("type", "new_player");
        busProducer.write(json.encode());
    }

    // method to send a message to the server letting them know whether a current game is being joined
    // or a new game has to be created
    public void sendCurrentOrNewGame() {
        // hardcoded to yes, we want a new game. we can change the input later depending on how we want to ask the
        // user this in our UI
        String choice = "yes";
        JsonObject json = new JsonObject();
        json.put("player_choice", choice);
        json.put("type", "new_or_current_game");
        busProducer.write(json.encode());
    }

    // method to load in the account page of the particular player
    public void receiveUpdatedAccountPage(JsonObject json) throws IOException {

        Platform.runLater(() -> {

            // setting the scene to the next page
            Stage stage = (Stage) ((Node) actionEvent.getSource()).getScene().getWindow();
            stage.setTitle("Stock Simulator 2.0 Account Page");
            stage.setScene(new Scene(root, 1500, 750));
            // actually updating our accountPage with the new player information
            accountPageController.lblAccountName.setText(json.getString("player_name") + "'s Account");
            accountPageController.lstStockSelect.getItems().clear();
            JsonArray jsonArray = json.getJsonArray("stocks");
            for (int index = 0; index < jsonArray.size(); ++index) {
                accountPageController.lstStockSelect.getItems().add(jsonArray.getString(index));
            }
            stage.show();

            System.out.println("everything updated very nicely ###################");

        });

    }

}


AccountPageController Class

package sample;

import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.core.eventbus.MessageProducer;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import javafx.application.Platform;
import javafx.event.Event;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.chart.LineChart;
import javafx.scene.chart.NumberAxis;
import javafx.scene.chart.XYChart;
import javafx.scene.control.*;
import javafx.scene.layout.AnchorPane;
import javafx.stage.Stage;
import org.slf4j.Logger;

import javafx.event.ActionEvent;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.ArrayList;

public class AccountPageController {

    // all fx elements will be initialized here
    @FXML
    AnchorPane anchAccountPage;
    @FXML
    ListView lstStockSelect;
    @FXML
    Label lblAccountName, lblStockName, lblCurrentSharePrice, lblCurrentSharePriceNumber;
    @FXML
    NumberAxis xaxisStock, yaxisStock;
    @FXML
    TextField txtfiNumOfShares;
    @FXML
    LineChart chrtStock;
    @FXML
    Button btnBuyShares, btnSellShares, btnStart;

    private ClientHandler clientHandler = null;
    private Logger logger = null;

    // to communicate with vertx websocket using verticle
    private EventBus vertxEventBus = null;
    // to receive messages from server
    private MessageConsumer<String> busConsumer = null;
    // to send messages to server
    private MessageProducer<String> busProducer = null;

    // method that will receive all of the objects required in order to communicate with the server (this was all
    // initialized in the StartingPageController, so it needs to be transferred to every other fxController class)
    public void transferVertxObjects(ClientHandler clientHandler) {

        this.clientHandler = clientHandler;
        this.logger = LoggerFactory.getLogger(AccountPageController.class);
        this.vertxEventBus = clientHandler.getVertxEventBus();
        this.busConsumer = vertxEventBus.consumer("socket-inbound");
        this.busProducer = vertxEventBus.publisher("socket-outbound");

        // attach a handler to receive messages
        this.busConsumer.handler(msg -> {

            String message = msg.body();
            logger.info("Received {}", message);

            // handles all incoming messages from GameClientVerticle
            try {
                handleMessage(message);
            } catch (IOException e) {
                e.printStackTrace();
            }

            // for now echo it back
            // busProducer.write("ECHO " + message);
        });
    }

    // method takes in every message that is incoming from the busProducer in the GameClientVerticle and processes it
    public void handleMessage(String message) throws IOException {
        JsonObject json = new JsonObject(message);
        String messageType = json.getString("type");
        if (messageType.equals("stock_chart_data_full")) {
            // Platform.runLater()s must consistently be used due to the fact that JavaFX changes and vertx processes
            // cannot occur on the same Thread
            Platform.runLater(() -> {
                updateChartFull(json);
            });
        } else if (messageType.equals("stock_chart_data_interval")) {
            Platform.runLater(() -> {
                updateChartInterval(json);
            });
        }
    }

    // methods below will update the graph to whatever stock has been selected at the given time

    // method will send a request to server in order to get the full data for a specific stock
    public void sendSelectedStockFull() {
        String stockSymbol = (String) lstStockSelect.getSelectionModel().getSelectedItem();
        JsonObject json = new JsonObject();
        json.put("stock_symbol", stockSymbol);
        json.put("type", "stock_data_request_full");
        busProducer.write(json.encode());
    }

    // these variables will be decided by the actual player in the game, but we can use test values for now
    private double intervalTime = 3000; // in milliseconds
    private double amountOfDataPerInterval = 10; // in point of data

    // method will send a request to server in order to get data in smaller intervals
    public void sendSelectedStockInterval() {
        btnStart.setDisable(true);

        JsonArray jsonArray = new JsonArray();
        for (Object stockSymbol: lstStockSelect.getItems()) {
            jsonArray.add((String) stockSymbol);
        }

        JsonObject json = new JsonObject();
        json.put("stock_symbols", jsonArray);
        json.put("interval_time", intervalTime);
        json.put("amount_per_interval", amountOfDataPerInterval);
        json.put("type", "stock_data_request_interval");
        busProducer.write(json.encode());
    }

    // method will actually receive the full amount of data and update the graph accordingly
    public void updateChartFull(JsonObject json) {

        lblStockName.setText(json.getString("stock_name") + " (" + json.getString("stock_symbol") + ")");
        lblCurrentSharePrice.setText("The Current Share Price for " + json.getString("stock_symbol") + ":");
        lblCurrentSharePriceNumber.setText("--- USD");

        chrtStock.getData().clear();

        xaxisStock.setLabel("Daily Time Series");
        yaxisStock.setLabel("Open Price Per Day");

        double minDoubleValue = Double.MAX_VALUE;
        double maxDoubleValue = Double.MIN_VALUE;
        XYChart.Series series = new XYChart.Series();
        for (int i = 0;i < json.getJsonArray("open_prices").size();i += 2) {
            double yValue = json.getJsonArray("open_prices").getDouble(i);
            series.getData().add(new XYChart.Data(i, yValue));
            if (yValue <= minDoubleValue) {
                minDoubleValue = yValue;
            } else if (yValue >= maxDoubleValue) {
                maxDoubleValue = yValue;
            }
        }

        yaxisStock.setAutoRanging(false);
        yaxisStock.setLowerBound(minDoubleValue - 10.0);
        yaxisStock.setUpperBound(maxDoubleValue + 10.0);

        xaxisStock.setAutoRanging(true);

        chrtStock.setCreateSymbols(false);
        chrtStock.setLegendVisible(false);

        chrtStock.getData().add(series);

    }

    // used in our updateChartInterval() method
    private boolean firstTimeRun = true;
    private ArrayList<StockIntervalData> stockIntervalDataList = new ArrayList<>();
    private StockIntervalData currentStock = null;
    // for now the first thing the graph shows will automatically be set to the first stock in the list
    private String previousStockSelected = "--NONE--";
    private String selectedStockSymbol;

    // method will be built in order to update a chart based on intervals of data that come in from the server
    public void updateChartInterval(JsonObject json) {

        selectedStockSymbol = (String) lstStockSelect.getItems().get(0);

        // if-statement so that we only create all of our StockIntervalData objects only once
        if (firstTimeRun) {
            for (int i = 0;i < json.getJsonArray("complete_interval_data").size();i++) {
                JsonObject jsonObject = json.getJsonArray("complete_interval_data").getJsonObject(i);
                stockIntervalDataList.add(new StockIntervalData(jsonObject.getString("stock_name"), jsonObject.getString("stock_symbol")));
            }
            firstTimeRun = false;
        }

        // clearing graph and adding a different series to graph if user clicks on a different stock
        selectedStockSymbol = (String) lstStockSelect.getSelectionModel().getSelectedItem();
        if (selectedStockSymbol != null) {

            if (!previousStockSelected.equals(selectedStockSymbol)) {
                previousStockSelected = selectedStockSymbol;
                chrtStock.getData().clear();
                for (StockIntervalData stock: stockIntervalDataList) {
                    if (stock.getStockSymbol().equals(selectedStockSymbol)) {
                        stock.addSeriesToGraph(chrtStock);
                        currentStock = stock;
                    }
                }
            }

            // actually retrieving the data from the JsonObjects
            for (int i = 0;i < json.getJsonArray("complete_interval_data").size();i++) {
                JsonObject jsonObject = json.getJsonArray("complete_interval_data").getJsonObject(i);
                for (StockIntervalData stockIntervalData: stockIntervalDataList) {
                    if (stockIntervalData.getStockSymbol().equals(jsonObject.getString("stock_symbol"))) {
                        for (int j = 0;j < jsonObject.getJsonArray("open_prices").size();j++) {
                            stockIntervalData.addData(jsonObject.getJsonArray("open_prices").getDouble(j));
                        }
                    }
                }
            }

            // method call will change all the labels associated with the graph, as well as any axis changes that might be required
            currentStock.graphData(chrtStock, xaxisStock, yaxisStock, lblStockName, lblCurrentSharePrice, lblCurrentSharePriceNumber);

        }

    }

    // method will be used for abstraction purposes in both the buy and sell request functions below
    public void sendShareTransaction(String type) {
        String latestSharePrice = lblCurrentSharePriceNumber.getText().substring(0, lblCurrentSharePriceNumber.getText().indexOf(" "));
        int numOfSharesRequested = Integer.parseInt(txtfiNumOfShares.getText());
        JsonObject jsonObject = new JsonObject();
        jsonObject.put("stock_symbol", selectedStockSymbol);
        jsonObject.put("share_price", latestSharePrice);
        jsonObject.put("number_of_shares", numOfSharesRequested);
        jsonObject.put("type", type);
        busProducer.write(jsonObject.encode());
    }

    // method will send a request to the server so that the player can buy shares in a stock
    public void sendBuyRequest() {
        sendShareTransaction("buy_request");
    }

    // method will send a request to the server so that the player can sell shares in a stock
    public void sendSellRequest() {
        sendShareTransaction("sell_request");
    }

}


ClientHandler Class

package sample;

import io.vertx.core.Vertx;
import io.vertx.core.eventbus.EventBus;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ClientHandler {

    private final Logger logger;
    private final Vertx vertx;

    public Vertx getVertxInstance() {
        return vertx;
    }

    public EventBus getVertxEventBus() {
        return vertx.eventBus();
    }

    public ClientHandler(String serverAddress, Integer serverPort, String nickname) {
        logger = LoggerFactory.getLogger(ClientHandler.class);
        this.vertx = Vertx.vertx();
    }

    public void startClient(String serverAddress, Integer serverPort, String nickname) {

        final GameClientVerticle gameClientVerticle = new GameClientVerticle(serverAddress, serverPort, nickname);
        // deployVerticle is asynchronous (occurs after a period of time)
        vertx.deployVerticle(gameClientVerticle, deployStatus -> {
            if (deployStatus.succeeded()) {
                logger.info("Deployed callback");
            } else {
                logger.info(deployStatus.cause().getLocalizedMessage());
            }
        });

    }

}


GameClientVerticle Class

package sample;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.MultiMap;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.core.eventbus.MessageProducer;
import io.vertx.core.http.HttpClient;
import io.vertx.core.http.HttpClientOptions;
import io.vertx.core.http.WebSocket;
import io.vertx.core.http.WebsocketVersion;
import io.vertx.core.json.JsonObject;
import javafx.application.Platform;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class GameClientVerticle extends AbstractVerticle {


    public static String CLIENT_ADDRESS;
    public static Integer CLIENT_PORT;

    private final Logger logger;

    private final String serverAddress;
    private final Integer serverPort;
    private final String nickname;

    private EventBus vertxEventBus = null;
    private MessageConsumer<String> busConsumer = null;
    private MessageProducer<String> busProducer = null;

    private HttpClient  httpClient = null;
    private WebSocket webSocket = null;

    public GameClientVerticle(String serverAddress, Integer serverPort, String nickname) {
        logger = LoggerFactory.getLogger(GameClientVerticle.class);
        this.serverAddress = serverAddress;
        this.serverPort = serverPort;
        this.nickname = nickname;
    }

    @Override
    public void start(Future<Void> startFuture) throws Exception {
        logger.info("Deployed");

        this.vertxEventBus = vertx.eventBus();

        // the strings act as addresses
        // essentially any busConsumer with socket-inbound will receive this message
        // likewise any message sent by the busProducer will be sent to this busConsumer as long as the address is the same
        busProducer = vertxEventBus.publisher("socket-inbound");
        busConsumer = vertxEventBus.consumer("socket-outbound");

        // anything that is sent to the GameClientVerticle from our busProducer in the fxController will automatically
        // be directed straight to our server since our WebSocket is bridged to our EventBus
        busConsumer.handler(msg -> {
            // Send message to server
            String message = msg.body();
            logger.info("Sending {}", message);
            sendMessageToServer(message);
        });

        connect();
        startFuture.complete();
    }

    public void connect() throws Exception {

        HttpClientOptions httpOptions = new HttpClientOptions()
                .setConnectTimeout(1000)
                .setIdleTimeout(5000)
                .setDefaultHost("localhost")
                .setDefaultPort(8080)
                .setSsl(false)
                .setLogActivity(true);
        httpClient = vertx.createHttpClient(httpOptions);
        httpClient.websocket(8080, "localhost", "/", socket -> {
            logger.info("Connection ID=" + socket.textHandlerID());
            webSocket = socket;

            // this message below is being sent to our fxController since the event bus is between the fxController
            // and the GameClientVerticle, so when the busConsumer receives this said message, we can then begin
            // sending our own messages since that is officially when the socket is up and running
            JsonObject json = new JsonObject();
            json.put("type", "socket_connected");
            busProducer.write(json.encode());

            webSocket.endHandler((Void) -> {
                logger.info("Socket ended");
                webSocket = null;
            });

            webSocket.closeHandler((Void) -> {
                logger.info("Socket closed");
                webSocket = null;
            });

            webSocket.handler(buffer -> {
                logger.info("Received {}", buffer.toString());
                // automatically sends to all busConsumers because they all have the same address
                busProducer.write(buffer.toString());
            });
//
//            // Register to receive messages
//            vertxEventBus.consumer("socket-inbound", message -> {
//                String messageStr = message.body().toString();
//                logger.info("Received {}", messageStr);
//            });

        });
    }

    private void sendMessageToServer(String message) {
        if (webSocket != null) {
            webSocket.writeTextMessage(message);
        }
    }



}


StockIntervalData Class

package sample;

import javafx.scene.chart.LineChart;
import javafx.scene.chart.NumberAxis;
import javafx.scene.chart.XYChart;
import javafx.scene.control.Label;

import java.util.ArrayList;

// class will help us manage data being sent to client by the server
public class StockIntervalData {

    // all variables located here
    private String stockName, stockSymbol;
    private ArrayList<Double> data;
    private XYChart.Series series;
    private int seriesDataCount;

    // class constructor
    public StockIntervalData(String stockName, String stockSymbol) {
        this.stockName = stockName;
        this.stockSymbol = stockSymbol;
        data = new ArrayList<>();
        series = new XYChart.Series();
    }

    // all getter methods located here
    public String getStockName() { return stockName; }
    public String getStockSymbol() { return stockSymbol; }
    public ArrayList<Double> getData() { return data; }
    public XYChart.Series getSeries() { return series; }
    public int getSeriesDataCount() { return seriesDataCount; }

    // method to add data to both our arrayList as well as our series
    public void addData(double datum) {
        data.add(datum);
        series.getData().add(new XYChart.Data<>(seriesDataCount, datum));
        seriesDataCount++;
    }

    // method to add the respective series to the chart
    public void addSeriesToGraph(LineChart lineChart) {
        lineChart.getData().add(series);
    }

    // method to graph the interval data
    public void graphData(LineChart lineChart, NumberAxis xaxisStock, NumberAxis yaxisStock, Label lblStockName,
                          Label lblCurrentSharePrice, Label lblCurrentSharePriceNumber) {
        System.out.println("CURRENTLY GRAPHING        " + stockName);
        lblStockName.setText(stockName + " (" + stockSymbol + ")");
        lblCurrentSharePrice.setText("The Current Share Price for " + stockSymbol + ":");
        lblCurrentSharePriceNumber.setText(data.get(data.size() - 1) + " USD");

        xaxisStock.setLabel("Daily Time Series");
        yaxisStock.setLabel("Open Price Per Day");

        double minDoubleValue = Double.MAX_VALUE;
        double maxDoubleValue = Double.MIN_VALUE;
        for (double yValue : data) {
            if (yValue <= minDoubleValue) {
                minDoubleValue = yValue;
            } else if (yValue >= maxDoubleValue) {
                maxDoubleValue = yValue;
            }
        }

        yaxisStock.setAutoRanging(false);
        if (minDoubleValue - 10.0 < 0) {
            yaxisStock.setLowerBound(0);
        } else {
            yaxisStock.setLowerBound(minDoubleValue - 10.0);
        }
        yaxisStock.setUpperBound(maxDoubleValue + 10.0);


        xaxisStock.setAutoRanging(true);

        lineChart.setCreateSymbols(false);
        lineChart.setLegendVisible(false);
    }



}


StartingPage FXML

<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.scene.control.Button?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.shape.Rectangle?>
<?import javafx.scene.text.Font?>

<AnchorPane prefHeight="750.0" prefWidth="1500.0" xmlns="http://javafx.com/javafx/11.0.1" xmlns:fx="http://javafx.com/fxml/1" fx:controller="sample.StartingPageController">
   <children>
      <Rectangle arcHeight="5.0" arcWidth="5.0" fill="LIGHTGRAY" height="750.0" stroke="BLACK" strokeType="INSIDE" width="1500.0" />
      <TextField fx:id="txtfiEnterNickname" layoutX="520.0" layoutY="323.0" prefHeight="46.0" prefWidth="459.0" promptText="nickname" />
      <Button fx:id="btnConnect" layoutX="530.0" layoutY="389.0" mnemonicParsing="false" onAction="#connectToServer" prefHeight="94.0" prefWidth="438.0" text="JOIN GAME">
         <font>
            <Font size="24.0" />
         </font></Button>
      <TextField fx:id="txtfiGameMode" layoutX="520.0" layoutY="266.0" prefHeight="46.0" prefWidth="459.0" promptText="mode" />
   </children>
</AnchorPane>


AccountPage FXML

<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.scene.chart.LineChart?>
<?import javafx.scene.chart.NumberAxis?>
<?import javafx.scene.control.Button?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.shape.Rectangle?>
<?import javafx.scene.text.Font?>

<AnchorPane fx:id="anchAccountPage" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="750.0" prefWidth="1500.0" xmlns="http://javafx.com/javafx/11.0.1" xmlns:fx="http://javafx.com/fxml/1" fx:controller="sample.AccountPageController">
    <children>
      <Rectangle arcHeight="5.0" arcWidth="5.0" fill="LIGHTGRAY" height="750.0" stroke="BLACK" strokeType="INSIDE" width="1500.0" />
      <Rectangle arcHeight="20.0" arcWidth="20.0" fill="#1668b4" height="642.0" layoutX="14.0" layoutY="92.0" stroke="BLACK" strokeType="INSIDE" strokeWidth="3.0" width="267.0" />
      <Rectangle arcHeight="20.0" arcWidth="20.0" fill="#41c4b7" height="532.0" layoutX="289.0" layoutY="202.0" stroke="BLACK" strokeType="INSIDE" strokeWidth="3.0" width="1197.0" />
        <ListView fx:id="lstStockSelect" layoutX="25.0" layoutY="104.0" prefHeight="620.0" prefWidth="244.0" />
      <Rectangle arcHeight="20.0" arcWidth="20.0" fill="#41c4b7" height="104.0" layoutX="289.0" layoutY="92.0" stroke="BLACK" strokeType="INSIDE" strokeWidth="3.0" width="1197.0" />
        <Label fx:id="lblStockName" alignment="CENTER" contentDisplay="CENTER" layoutX="306.0" layoutY="104.0" prefHeight="80.0" prefWidth="1164.0" text="SELECT A STOCK" textAlignment="CENTER" textFill="WHITE">
         <font>
            <Font size="39.0" />
         </font></Label>
        <LineChart fx:id="chrtStock" layoutX="793.0" layoutY="217.0" prefHeight="484.0" prefWidth="682.0">
            <xAxis>
                <NumberAxis side="BOTTOM" fx:id="xaxisStock" />
            </xAxis>
            <yAxis>
                <NumberAxis fx:id="yaxisStock" side="LEFT" />
            </yAxis>
        </LineChart>
        <Button fx:id="btnBuyShares" layoutX="398.0" layoutY="453.0" mnemonicParsing="false" prefHeight="55.0" prefWidth="267.0" text="BUY">
         <font>
            <Font size="24.0" />
         </font></Button>
        <Button fx:id="btnSellShares" layoutX="398.0" layoutY="516.0" mnemonicParsing="false" prefHeight="55.0" prefWidth="267.0" text="SELL">
         <font>
            <Font size="24.0" />
         </font></Button>
      <Rectangle arcHeight="20.0" arcWidth="20.0" fill="ORANGE" height="73.0" layoutX="15.0" layoutY="14.0" stroke="BLACK" strokeType="INSIDE" strokeWidth="3.0" width="1471.0" />
        <Label fx:id="lblAccountName" alignment="CENTER" contentDisplay="CENTER" layoutX="29.0" layoutY="23.0" prefHeight="55.0" prefWidth="1441.0" text="Account" textAlignment="CENTER" textFill="WHITE">
         <font>
            <Font name="System Bold" size="36.0" />
         </font></Label>
      <TextField fx:id="txtfiNumOfShares" layoutX="341.0" layoutY="389.0" prefHeight="55.0" prefWidth="383.0" promptText="number of shares" />
      <Rectangle arcHeight="20.0" arcWidth="20.0" fill="#1668b4" height="158.0" layoutX="306.0" layoutY="217.0" stroke="BLACK" strokeType="INSIDE" strokeWidth="3.0" width="454.0" />
        <Label fx:id="lblCurrentSharePrice" alignment="CENTER" contentDisplay="CENTER" layoutX="315.0" layoutY="231.0" prefHeight="46.0" prefWidth="434.0" text="Current Share Price" textAlignment="CENTER" textFill="WHITE">
         <font>
            <Font size="20.0" />
         </font></Label>
      <Label fx:id="lblCurrentSharePriceNumber" alignment="CENTER" contentDisplay="CENTER" layoutX="321.0" layoutY="280.0" prefHeight="80.0" prefWidth="422.0" text="\$$$" textAlignment="CENTER" textFill="WHITE">
         <font>
            <Font size="48.0" />
         </font>
      </Label>
      <Button fx:id="btnStart" layoutX="29.0" layoutY="27.0" mnemonicParsing="false" onAction="#sendSelectedStockInterval" prefHeight="46.0" prefWidth="86.0" text="START">
         <font>
            <Font size="18.0" />
         </font>
      </Button>
    </children>
</AnchorPane>
